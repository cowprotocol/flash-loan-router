{
  "language": "Solidity",
  "sources": {
    "src/FlashLoanRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8;\n\nimport {IBorrower} from \"./interface/IBorrower.sol\";\nimport {ICowSettlement} from \"./interface/ICowSettlement.sol\";\nimport {IFlashLoanRouter} from \"./interface/IFlashLoanRouter.sol\";\nimport {Loan} from \"./library/Loan.sol\";\nimport {LoansWithSettlement} from \"./library/LoansWithSettlement.sol\";\nimport {ICowAuthentication} from \"./vendored/ICowAuthentication.sol\";\nimport {IERC20} from \"./vendored/IERC20.sol\";\n\n/// @title Flash-loan Router\n/// @author CoW DAO developers\n/// @notice Solver contract for CoW Protocol that requests flash loans before\n/// executing a settlement. Every CoW Protocol solver can call this\n/// contract to borrow the funds needed for executing a settlement.\ncontract FlashLoanRouter is IFlashLoanRouter {\n    using LoansWithSettlement for bytes;\n\n    /// @notice Flag address signalling that the router is not currently\n    /// preparing or executing a settlement. This is the case at the start or\n    /// at the end of the call to `flashLoanAndSettle`.\n    IBorrower internal constant READY = IBorrower(address(0));\n    /// @notice Flag address signalling that the router is currently in the\n    /// process of executing a settlement.\n    IBorrower internal constant SETTLING = IBorrower(address(bytes20(keccak256(\"FlashLoanRouter: settling\"))));\n\n    /// @inheritdoc IFlashLoanRouter\n    ICowSettlement public immutable settlementContract;\n    /// @inheritdoc IFlashLoanRouter\n    ICowAuthentication public immutable settlementAuthentication;\n\n    /// @notice This variable has the following possible values:\n    /// - `READY` (default), before or after a (successful) settlement\n    /// - `SETTLING`, if the flash-loan collection phase terminated and the last\n    ///   phase of the settlement with flash loan has started.\n    /// - The address of the borrower that is expected to call this contract\n    /// Â  back.\n    /// This variable it the main actor responsible for controlling the\n    /// execution order of flash loan and final settlement.\n    IBorrower internal transient pendingBorrower;\n    /// @notice The router expects the borrower to send back some data verbatim.\n    /// The hash of the data is stored in this variable for validation.\n    bytes32 internal transient pendingDataHash;\n\n    /// @notice Only a solver of CoW Protocol can call this function.\n    modifier onlySolver() {\n        require(settlementAuthentication.isSolver(msg.sender), \"Not a solver\");\n        _;\n    }\n\n    /// @notice The router is waiting for a call back from a specific borrower,\n    /// no other addresses should be calling this function.\n    modifier onlyPendingBorrower() {\n        require(msg.sender == address(pendingBorrower), \"Not the pending borrower\");\n        _;\n    }\n\n    /// @param _settlementContract The settlement contract that this router will\n    /// be supporting.\n    constructor(ICowSettlement _settlementContract) {\n        settlementContract = _settlementContract;\n        settlementAuthentication = ICowAuthentication(_settlementContract.authenticator());\n    }\n\n    /// @inheritdoc IFlashLoanRouter\n    /// @dev Despite this contract being expected to be a solver, there is no\n    /// way for this contract to call itself at `flashLoanAndSettle`.\n    function flashLoanAndSettle(Loan.Data[] calldata loans, bytes calldata settlement) external onlySolver {\n        require(pendingBorrower == READY, \"Another settlement in progress\");\n        bytes memory loansWithSettlement = LoansWithSettlement.encode(loans, settlement);\n        borrowNextLoan(loansWithSettlement);\n        // The following parameter is expected to be set before the final call\n        // to `settle()` is executed. This flag being set means that no more\n        // calls to `borrowerCallBack` are pending nor possible.\n        require(pendingBorrower == SETTLING, \"Terminated without settling\");\n        // We reset the borrower to make it possible to call this function again\n        // in the same transaction.\n        pendingBorrower = READY;\n    }\n\n    /// @inheritdoc IFlashLoanRouter\n    /// @dev Note that the contract cannot call itself as a borrower because it\n    /// doesnt implement the expected interface.\n    function borrowerCallBack(bytes memory loansWithSettlement) external onlyPendingBorrower {\n        // When the borrower is called, it's given some extra data that is\n        // expected to be passed back here without changes.\n        require(loansWithSettlement.hash() == pendingDataHash, \"Data from borrower not matching\");\n        borrowNextLoan(loansWithSettlement);\n    }\n\n    /// @notice Takes the input loans with settlements; if none is available, it\n    /// calls settle; otherwise, it requests the next loan from the borrower.\n    /// @param loansWithSettlement List of loans with settlement to process.\n    function borrowNextLoan(bytes memory loansWithSettlement) private {\n        if (loansWithSettlement.loanCount() == 0) {\n            // We set the borrower to some value different from `READY` or any\n            // intermediate borrower address to prevent reentrancy.\n            pendingBorrower = SETTLING;\n            settle(loansWithSettlement.destroyToSettlement());\n        } else {\n            (uint256 amount, IBorrower borrower, address lender, IERC20 token) = loansWithSettlement.popLoan();\n            pendingBorrower = borrower;\n            pendingDataHash = loansWithSettlement.hash();\n            borrower.flashLoanAndCallBack(lender, token, amount, loansWithSettlement);\n        }\n    }\n\n    /// @notice Execute a CoW Protocol settlement.\n    /// @param settlement The ABI-encoded call data for a call to `settle()` (as\n    /// in `abi.encodeCall`).\n    function settle(bytes memory settlement) private {\n        require(selector(settlement) == ICowSettlement.settle.selector, \"Only settle() is allowed\");\n        (bool result,) = address(settlementContract).call(settlement);\n        require(result, \"Settlement reverted\");\n    }\n\n    /// @notice Extracts the Solidity ABI selector for the specified ABI-encode\n    /// call data.\n    /// @dev We assume that the input array is a valid bytes array as stored in\n    /// memory by Solidity and its content can be read.\n    /// @param callData ABI-encoded call data as per `abi.encodeCall`.\n    /// @return result The 4 byte function selector of the call encoded in\n    /// this interaction (or zero bytes if the data is shorter).\n    function selector(bytes memory callData) internal pure returns (bytes4 result) {\n        if (callData.length >= 4) {\n            // NOTE: Read the first 32 bytes in the array. The value does not\n            // need to be shifted since `bytesN` values are left aligned, and\n            // the value does not need to be masked since masking occurs when\n            // the value is accessed and not stored. The first word of the\n            // memory data is the call data length, the content starts in the\n            // next word.\n            // <https://docs.soliditylang.org/en/v0.8.28/internals/layout_in_memory.html>\n            // <https://docs.soliditylang.org/en/v0.8.28/assembly.html#access-to-external-variables-functions-and-libraries>\n            // solhint-disable-next-line no-inline-assembly\n            // Addition overflow can only happen if the input bytes point to a\n            // memory address close to (`type(uint256).max`), which would not be\n            // accessible in Solidity without the call running out of gas.\n            assembly {\n                result := mload(add(callData, 32))\n            }\n        }\n    }\n}\n"
    },
    "src/interface/IBorrower.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8;\n\nimport {IERC20} from \"../vendored/IERC20.sol\";\nimport {ICowSettlement} from \"./ICowSettlement.sol\";\nimport {IFlashLoanRouter} from \"./IFlashLoanRouter.sol\";\n\n/// @title Flash-loan Borrower\n/// @author CoW DAO developers\n/// @notice The CoW Protocol flash-loan router uses the flash-loan borrower\n/// contract as the intermediary that requests funds through a flash loan.\n/// Different flash-loan protocols have different logic for flash loans:\n/// usually, the call-back function name and parameters are different. Each\n/// flash-loan protocol must have a dedicated Borrower contract to be supported\n/// by the flash-loan router.\n/// A concrete borrower implementation generally calls a dedicated flash-loan\n/// function on the lender and then awaits for a callback from it. The borrower\n/// then calls back the router for further processing.\ninterface IBorrower {\n    /// @notice Requests a flash loan with the specified parameters from the\n    /// lender and, once the funds have been received, call back the router\n    /// while passing through the specified custom data. The flash-loan\n    /// repayment is expected to take place during the final settlement in the\n    /// router.\n    /// @param lender The address of the flash-loan lender from which to borrow.\n    /// @param token The token that is requested in the flash loan.\n    /// @param amount The amount of funds requested from the lender.\n    /// @param callBackData The data to send back when calling the router once\n    /// the loan is received.\n    function flashLoanAndCallBack(address lender, IERC20 token, uint256 amount, bytes calldata callBackData) external;\n\n    /// @notice Approves the target address to spend the specified token on\n    /// behalf of the Borrower up to the specified amount.\n    /// @dev In general, the only way to transfer funds out of this contract is\n    /// through a call to this function and a subsequent call to `transferFrom`.\n    /// This approval is expected to work similarly to an ERC-20 approval (in\n    /// particular, the allowance doesn't reset once the call is terminated).\n    /// @param token The token to approve for transferring.\n    /// @param target The address that will be allowed to spend the token.\n    /// @param amount The amount of tokens to set as the allowance.\n    function approve(IERC20 token, address target, uint256 amount) external;\n\n    /// @notice The settlement contract supported by this contract.\n    function settlementContract() external view returns (ICowSettlement);\n\n    /// @notice The router contract that manages this borrower contract. It will\n    /// be called back once the flash-loan proceeds are received and is the only\n    /// address that can trigger a flash loan request.\n    function router() external view returns (IFlashLoanRouter);\n}\n"
    },
    "src/interface/ICowSettlement.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8;\n\n/// @notice An interface for CoW Protocol's settlement contract that only\n/// enumerates the functions and types needed for this project.\n/// For more information, see the project's repository:\n/// <https://github.com/cowprotocol/contracts/blob/9c1984b864d0a6703a877a088be6dac56450808c/src/contracts/GPv2Settlement.sol>\n/// The code and comments have been mostly copied from the linked resources.\ninterface ICowSettlement {\n    /// @notice A struct representing a trade to be executed as part a batch\n    /// settlement.\n    /// @dev See <https://github.com/cowprotocol/contracts/blob/9c1984b864d0a6703a877a088be6dac56450808c/src/contracts/libraries/GPv2Trade.sol#L14-L28>.\n    struct Trade {\n        uint256 sellTokenIndex;\n        uint256 buyTokenIndex;\n        address receiver;\n        uint256 sellAmount;\n        uint256 buyAmount;\n        uint32 validTo;\n        bytes32 appData;\n        uint256 feeAmount;\n        uint256 flags;\n        uint256 executedAmount;\n        bytes signature;\n    }\n\n    /// @notice Interaction data for performing arbitrary contract interactions.\n    /// Submitted to [`GPv2Settlement.settle`] for code execution.\n    /// @dev See <https://github.com/cowprotocol/contracts/blob/9c1984b864d0a6703a877a088be6dac56450808c/src/contracts/libraries/GPv2Interaction.sol#L7-L13>.\n    struct Interaction {\n        address target;\n        uint256 value;\n        bytes callData;\n    }\n\n    /// @notice The authenticator is used to determine who can call the settle\n    /// function. That is, only authorized solvers have the ability to invoke\n    /// settlements. Any valid authenticator implements an isSolver method\n    /// called by the onlySolver modifier below.\n    /// @dev See <https://github.com/cowprotocol/contracts/blob/9c1984b864d0a6703a877a088be6dac56450808c/src/contracts/GPv2Settlement.sol#L28-L32>.\n    function authenticator() external returns (address);\n\n    /// @notice Settle the specified orders at a clearing price. Note that it is\n    /// the responsibility of the caller to ensure that all GPv2 invariants are\n    /// upheld for the input settlement, otherwise this call will revert.\n    /// Namely:\n    /// - All orders are valid and signed\n    /// - Accounts have sufficient balance and approval.\n    /// - Settlement contract has sufficient balance to execute trades. Note\n    ///   this implies that the accumulated fees held in the contract can also\n    ///   be used for settlement. This is OK since:\n    ///   - Solvers need to be authorized\n    ///   - Misbehaving solvers will be slashed for abusing accumulated fees for\n    ///     settlement\n    ///   - Critically, user orders are entirely protected\n    ///\n    /// @param tokens An array of ERC20 tokens to be traded in the settlement.\n    /// Trades encode tokens as indices into this array.\n    /// @param clearingPrices An array of clearing prices where the `i`-th price\n    /// is for the `i`-th token in the [`tokens`] array.\n    /// @param trades Trades for signed orders.\n    /// @param interactions Smart contract interactions split into three\n    /// separate lists to be run before the settlement, during the settlement\n    /// and after the settlement respectively.\n    /// @dev See <https://github.com/cowprotocol/contracts/blob/9c1984b864d0a6703a877a088be6dac56450808c/src/contracts/GPv2Settlement.sol#L99-L126>.\n    function settle(\n        address[] calldata tokens,\n        uint256[] calldata clearingPrices,\n        Trade[] calldata trades,\n        Interaction[][3] calldata interactions\n    ) external;\n}\n"
    },
    "src/interface/IFlashLoanRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8;\n\nimport {Loan} from \"../library/Loan.sol\";\nimport {ICowAuthentication} from \"../vendored/ICowAuthentication.sol\";\nimport {ICowSettlement} from \"./ICowSettlement.sol\";\n\n/// @title Flash-loan Router Interface\n/// @author CoW DAO developers\n/// @notice Interface describing the functions available for interacting with\n/// the flash-loan router.\n/// @dev The flash loan router is intended to be a solver for CoW Protocol.\ninterface IFlashLoanRouter {\n    /// @notice Request all flash loan specified in the input and, after that,\n    /// executes the specified settlement.\n    /// @dev It's the solver's responsibility to make sure the loan is specified\n    /// correctly. The router contract offers no validation of the fact that\n    /// the flash loan proceeds are available for spending.\n    ///\n    /// The repayment of a flash loan is different based on the protocol. For\n    /// example, some expect to retrieve the funds from this borrower contract\n    /// through `transferFrom`, while other check the lender balance is as\n    /// expected after the flash loan has been processed. The executed\n    /// settlement must be built to cater to the needs of the specified lender.\n    ///\n    /// A settlement can be executed at most once in a call. The settlement\n    /// data cannot change during execution. Only the settle function can be\n    /// called. All of this is also the case if the lender is untrusted.\n    /// @param loans The list of flash loans to be requested before the\n    /// settlement is executed. The loans will be requested in the specified\n    /// order.\n    /// @param settlement The ABI-encoded bytes for a call to `settle()` (as\n    /// in `abi.encodeCall`).\n    function flashLoanAndSettle(Loan.Data[] calldata loans, bytes calldata settlement) external;\n\n    /// @notice Once a borrower has received the proceeds of a flash loan, it\n    /// calls back the router through this function.\n    /// @param encodedLoansWithSettlement The data the borrower received when\n    /// it was called, without any modification.\n    function borrowerCallBack(bytes calldata encodedLoansWithSettlement) external;\n\n    /// @notice The settlement contract supported by this router. This is the\n    /// contract that will be called when the settlement is executed.\n    function settlementContract() external returns (ICowSettlement);\n\n    /// @notice The settlement authenticator contract for CoW Protocol. This\n    /// contract determines who the solvers for CoW Protocol are.\n    function settlementAuthentication() external returns (ICowAuthentication);\n}\n"
    },
    "src/library/Loan.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8;\n\nimport {IBorrower} from \"../interface/IBorrower.sol\";\nimport {IERC20} from \"../vendored/IERC20.sol\";\n\n/// @title Loan Library\n/// @author CoW DAO developers\n/// @notice A library describing a flash-loan request by the flash-loan router\n/// and providing related utility functions.\nlibrary Loan {\n    /// @notice The representation of a flash-loan request by the flash-loan\n    /// router.\n    struct Data {\n        /// @notice The amount of funds requested from the lender.\n        uint256 amount;\n        /// @notice The contract that directly requests the flash loan from the\n        /// lender and eventually calls back the router.\n        IBorrower borrower;\n        /// @notice The contract that loans out the funds to the borrower.\n        address lender;\n        /// @notice The token that is requested in the flash loan.\n        IERC20 token;\n    }\n\n    /// @notice A type that wraps a pointer to raw data in memory.\n    /// @dev A loan is expected to be encoded in memory as follows:\n    ///\n    /// Content: |--  amount  --||-- borrower --||--  lender  --||--  token   --|\n    /// Length:  |<--32 bytes-->||<--20 bytes-->||<--20 bytes-->||<--20 bytes-->|\n    type EncodedData is uint256;\n\n    // This is a list of offsets to add to the memory pointer to get the memory\n    // location of the respective loan parameter. Note: -12 because addresses\n    // are zero-padded to the left and mload/mstore work on groups of 32 bytes.\n    uint256 private constant OFFSET_BORROWER = 32 - 12;\n    uint256 private constant OFFSET_LENDER = 32 + 1 * 20 - 12;\n    uint256 private constant OFFSET_TOKEN = 32 + 2 * 20 - 12;\n\n    /// @notice The number of sequential bytes required to encode a loan in\n    /// memory.\n    uint256 internal constant ENCODED_LOAN_BYTE_SIZE = 32 + 3 * 20;\n\n    /// @notice Write the input loan to the memory location pointed to by the\n    /// input encodedLoan.\n    /// @param encodedLoan The memory location from which to start writing the\n    /// byte representation of the loan. It is assumed to have at least\n    /// `ENCODED_LOAN_BYTE_SIZE` available from that point it in memory.\n    /// @param loan The loan to store.\n    function store(EncodedData encodedLoan, Data calldata loan) internal pure {\n        uint256 amount = loan.amount;\n        IBorrower borrower = loan.borrower;\n        address lender = loan.lender;\n        IERC20 token = loan.token;\n\n        // Note: addresses are right-aligned, memory is written to starting\n        // from the end and overwriting the address left-side padding.\n        assembly (\"memory-safe\") {\n            // Unchecked: we assume that the input value isn't at the end of the\n            // memory array. This does not happen with Solidity standard memory\n            // allocation.\n            mstore(add(encodedLoan, OFFSET_TOKEN), token)\n            mstore(add(encodedLoan, OFFSET_LENDER), lender)\n            mstore(add(encodedLoan, OFFSET_BORROWER), borrower)\n            // offset is zero\n            mstore(encodedLoan, amount)\n        }\n    }\n\n    /// @notice Reads the loan parameter from the input location in memory.\n    /// @param loan The memory location from which to read the loan.\n    /// @return amount The amount to be borrowed (see `Loan.Data`).\n    /// @return borrower The address of the borrower contract (see `Loan.Data`).\n    /// @return lender The lender address (see `Loan.Data`).\n    /// @return token The token to borrow (see `Loan.Data`).\n    function decode(EncodedData loan)\n        internal\n        pure\n        returns (uint256 amount, IBorrower borrower, address lender, IERC20 token)\n    {\n        assembly (\"memory-safe\") {\n            // Note: the values don't need to be masked since masking occurs\n            // when the value is accessed and not when stored.\n            // <https://docs.soliditylang.org/en/v0.8.28/assembly.html#access-to-external-variables-functions-and-libraries>\n            amount := mload(loan)\n            borrower := mload(add(loan, OFFSET_BORROWER))\n            lender := mload(add(loan, OFFSET_LENDER))\n            token := mload(add(loan, OFFSET_TOKEN))\n        }\n    }\n}\n"
    },
    "src/library/LoansWithSettlement.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8;\n\nimport {IBorrower} from \"../interface/IBorrower.sol\";\nimport {IERC20} from \"../vendored/IERC20.sol\";\nimport {Bytes} from \"./Bytes.sol\";\nimport {Loan} from \"./Loan.sol\";\n\n/// @title Loans-with-settlement Library\n/// @author CoW DAO developers\n/// @notice A library describing a settlement execution through the flash-loan\n/// router and providing related utility functions.\n/// @dev This library is used to manage an encoded representation of a list of\n/// loans with a settlement as a bytes array. An abstract representation of it\n/// as a Solidity struct would be:\n///\n/// struct Data {\n///     Loan.Data[] loans;\n///     bytes settlement;\n/// }\n///\n/// The encoding of the bytes array for n loans is as follows:\n///\n/// Content: |-- number of loans, n --||-- ABI-encoded settlement --||-- n-th Loan  --||-- (n-1)-th Loan --|...|-- 1-st Loan  --|\n/// Length:  |<--     32 bytes     -->||<--    arbitrary size    -->||<--size(Loan)-->||<-- size(Loan)  -->|...|<--size(Loan)-->|\n///\n/// Loans are stored right to left so that it's easy to pop them in order\n/// without having to shift all remaining loans in memory.\nlibrary LoansWithSettlement {\n    using Bytes for bytes;\n    using Loan for Loan.EncodedData;\n\n    /// @notice The number of bytes reserved for the encoding of the loan count.\n    uint256 private constant LOAN_COUNT_SIZE = 32;\n\n    /// @notice The number of loans in the input.\n    /// @param loansWithSettlement The list of loans with settlement.\n    /// @return count Number of loans in the input.\n    function loanCount(bytes memory loansWithSettlement) internal pure returns (uint256 count) {\n        uint256 pointer = loansWithSettlement.memoryPointerToContent();\n        assembly (\"memory-safe\") {\n            count := mload(pointer)\n        }\n    }\n\n    /// @notice A collision-resistent identifier for the input list of loans\n    /// with settlement.\n    /// @param loansWithSettlement The list of loans with settlement to hash.\n    /// @return A collision-resistent identifier for the input.\n    function hash(bytes memory loansWithSettlement) internal pure returns (bytes32) {\n        return keccak256(loansWithSettlement);\n    }\n\n    /// @notice Store the list of loans and the settlement in a format\n    /// expected by this library.\n    /// @param loans List of requested loans.\n    /// @param settlement ABI-encoded settlement call data.\n    /// @return encodedLoansWithSettlement encoded representation of the input\n    /// parameters.\n    function encode(Loan.Data[] calldata loans, bytes calldata settlement)\n        internal\n        pure\n        returns (bytes memory encodedLoansWithSettlement)\n    {\n        uint256 encodedLength;\n        unchecked {\n            // Unchecked: the input values are bounded by the gas cost of\n            // including the data in a transaction.\n            encodedLength = LOAN_COUNT_SIZE + settlement.length + loans.length * Loan.ENCODED_LOAN_BYTE_SIZE;\n        }\n        encodedLoansWithSettlement = Bytes.allocate(encodedLength);\n\n        // Keep track of the fist yet-unwritten-to byte\n        uint256 head = encodedLoansWithSettlement.memoryPointerToContent();\n        assembly (\"memory-safe\") {\n            mstore(head, loans.length)\n        }\n\n        unchecked {\n            // Unchecked: `head` is bounded by `encodedLength`.\n            head += LOAN_COUNT_SIZE;\n        }\n        assembly (\"memory-safe\") {\n            calldatacopy(head, settlement.offset, settlement.length)\n        }\n\n        unchecked {\n            // Unchecked: `head` is bounded by `encodedLength`.\n            head += settlement.length;\n        }\n        for (uint256 i = loans.length; i > 0;) {\n            unchecked {\n                // Unchecked: loop condition prevents underflows.\n                i--;\n            }\n            Loan.EncodedData encodedLoan = Loan.EncodedData.wrap(head);\n            encodedLoan.store(loans[i]);\n            unchecked {\n                // Unchecked: `head` is bounded by `encodedLength`.\n                head += Loan.ENCODED_LOAN_BYTE_SIZE;\n            }\n        }\n    }\n\n    /// @notice Remove the next loan that is to be processed from the encoded\n    /// input data and return its parameter.\n    /// @dev The element are popped from the first to the last in the order they\n    /// were presented *before encoding*.\n    /// @param loansWithSettlement The encoded data from which to remove the\n    /// next loan. It must be a valid encoding of loans with settlement of\n    /// length at least one.\n    /// @return amount The amount to be borrowed (see `Loan.Data`).\n    /// @return borrower The address of the borrower contract (see `Loan.Data`).\n    /// @return lender The lender address (see `Loan.Data`).\n    /// @return token The token to borrow (see `Loan.Data`).\n    function popLoan(bytes memory loansWithSettlement)\n        internal\n        pure\n        returns (uint256 amount, IBorrower borrower, address lender, IERC20 token)\n    {\n        uint256 count = loanCount(loansWithSettlement);\n        require(count > 0, \"No loans available\");\n\n        uint256 updatedLoansWithSettlementLength;\n        unchecked {\n            // Unchecked: there is at least a loan.\n            count = count - 1;\n            // Unchecked: loansWithSettlement is properly encoded and has a\n            // loan, meaning that it has at least length\n            // `Loan.ENCODED_LOAN_BYTE_SIZE`\n            updatedLoansWithSettlementLength = loansWithSettlement.length - Loan.ENCODED_LOAN_BYTE_SIZE;\n        }\n\n        uint256 loansWithSettlementPointer = loansWithSettlement.memoryPointerToContent();\n        uint256 loanPointer;\n        unchecked {\n            // Unchecked: the pointer refers to a memory location inside\n            // loansWithSettlement, which is assumed to be a valid array.\n            loanPointer = loansWithSettlementPointer + updatedLoansWithSettlementLength;\n        }\n        Loan.EncodedData encodedLoan = Loan.EncodedData.wrap(loanPointer);\n\n        assembly (\"memory-safe\") {\n            // Efficiently reduce the size of the bytes array.\n            // The length of a dynamic array is stored at the first slot of the\n            // array and followed by the array elements.\n            // Memory is never freed, so the remaining unused memory won't\n            // affect the compiler.\n            // <https://docs.soliditylang.org/en/v0.8.28/internals/layout_in_memory.html>\n            mstore(loansWithSettlement, updatedLoansWithSettlementLength)\n            // Update first encoded element: the loan count.\n            mstore(loansWithSettlementPointer, count)\n        }\n\n        return encodedLoan.decode();\n    }\n\n    /// @notice Takes an input value with no encoded loans, destroys its content\n    /// in memory, and extracts the settlement stored as part of its encoding.\n    /// @dev This function overwrites the low-level memory representation of\n    /// the input value, meaning that trying to use the input after calling\n    /// this function leads to broken code. This functon takes full ownership\n    /// of the memory representing the input.\n    /// @param loansWithSettlement The encoded data representing loans with a\n    /// settlement. It must have valid encoding. This value will be destroyed\n    /// by calling this function and must not be used anywhere else.\n    /// @return settlement The settlement encoded in the input.\n    function destroyToSettlement(bytes memory loansWithSettlement) internal pure returns (bytes memory settlement) {\n        require(loanCount(loansWithSettlement) == 0, \"Pending loans\");\n        // We assume that the input is loans with a settlement, encoded as\n        // expected by this library. The settlement data is a subarray of the\n        // input: if we accept to override the input data with arbitrary data,\n        // we can carve out a valid ABI-encoded bytes array representing the\n        // settlement.\n        uint256 settlementLength;\n        unchecked {\n            // Unchecked: we assume `loansWithSettlement` to be valid encoded\n            // loans with settlement. Since there are no loans, this means that\n            // it comprises the loan count plus the settlement data, which is at\n            // least zero.\n            settlementLength = loansWithSettlement.length - LOAN_COUNT_SIZE;\n        }\n\n        // We rely on the fact that LOAN_COUNT_SIZE is 32, exactly the size\n        // needed to store the length of a memory array.\n        uint256 settlementPointer = loansWithSettlement.memoryPointerToContent();\n\n        assembly (\"memory-safe\") {\n            mstore(settlementPointer, settlementLength)\n            settlement := settlementPointer\n        }\n    }\n}\n"
    },
    "src/vendored/ICowAuthentication.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-or-later\n\n// Vendored from CoW DAO contracts with minor modifications:\n// - Formatted code\n// - Changed contract name\n// <https://github.com/cowprotocol/contracts/blob/9c1984b864d0a6703a877a088be6dac56450808c/src/contracts/interfaces/GPv2Authentication.sol>\n\npragma solidity >=0.7.6 <0.9.0;\n\n/// @title Gnosis Protocol v2 Authentication Interface\n/// @author Gnosis Developers\ninterface ICowAuthentication {\n    /// @dev determines whether the provided address is an authenticated solver.\n    /// @param prospectiveSolver the address of prospective solver.\n    /// @return true when prospectiveSolver is an authenticated solver, otherwise false.\n    function isSolver(address prospectiveSolver) external view returns (bool);\n}\n"
    },
    "src/vendored/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// Vendored from OpenZeppelin contracts with minor modifications:\n// - Formatted code\n// <https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v5.2/contracts/token/ERC20/IERC20.sol>\n// Note: v5.2 points to commit acd4ff74de833399287ed6b31b4debf6b2b35527.\n\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "src/library/Bytes.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8;\n\n/// @title Bytes Library\n/// @author CoW DAO developers\n/// @notice Helper functions to handle bytes array at a raw-memory level.\nlibrary Bytes {\n    uint256 private constant BYTES_LENGTH_SIZE = 32;\n\n    /// @notice Allocate a bytes array in memory with arbitrary data in it.\n    /// This is cheaper than `new bytes(length)` because it doesn't zero the\n    /// content of the array. It is supposed to be used when the newly allocated\n    /// memory will be fully overwritten at a later step.\n    /// @param length The length of the bytes array to create.\n    /// @return array A bytes array of the specified length with unknown data in\n    /// it.\n    function allocate(uint256 length) internal pure returns (bytes memory array) {\n        // <https://docs.soliditylang.org/en/v0.8.26/internals/layout_in_memory.html>\n        uint256 freeMemoryPointer;\n        assembly (\"memory-safe\") {\n            freeMemoryPointer := mload(0x40)\n        }\n\n        // Add to the free memory pointer the size of the array and the bytes\n        // for storing the array length.\n        uint256 updatedFreeMemoryPointer = freeMemoryPointer + BYTES_LENGTH_SIZE + length;\n        assembly (\"memory-safe\") {\n            // The array will be located at the first free available memory.\n            array := freeMemoryPointer\n            // The first 32 bytes are the array length.\n            mstore(array, length)\n            mstore(0x40, updatedFreeMemoryPointer)\n        }\n    }\n\n    /// @notice Return the location of the content of an array in memory. Note\n    /// that the array length is not part of the content.\n    /// @param array A bytes array.\n    /// @return ref The location in memory of the content of the array.\n    function memoryPointerToContent(bytes memory array) internal pure returns (uint256 ref) {\n        // Unchecked: arrays allocated by Solidity cannot cause an overflow,\n        // since a transaction would run out of gas long before reaching the\n        // length needed for an overflow. Arrays that were manually allocated\n        // through assembly may cause an overflow, but any attempt to read from\n        // or write to them would cause an out-of-gas revert.\n\n        assembly (\"memory-safe\") {\n            ref := add(array, BYTES_LENGTH_SIZE)\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "forge-std/=lib/forge-std/src/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 1000000,
      "details": {
        "peephole": true,
        "inliner": true,
        "jumpdestRemover": true,
        "orderLiterals": true,
        "deduplicate": true,
        "cse": true,
        "constantOptimizer": true,
        "yul": true,
        "simpleCounterForLoopUncheckedIncrement": true
      }
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode.object",
          "evm.bytecode.sourceMap",
          "evm.bytecode.linkReferences",
          "evm.deployedBytecode.object",
          "evm.deployedBytecode.sourceMap",
          "evm.deployedBytecode.linkReferences",
          "evm.deployedBytecode.immutableReferences",
          "evm.methodIdentifiers",
          "metadata"
        ]
      }
    },
    "evmVersion": "cancun",
    "viaIR": false,
    "libraries": {}
  }
}
